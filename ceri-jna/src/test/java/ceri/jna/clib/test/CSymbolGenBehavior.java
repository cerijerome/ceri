package ceri.jna.clib.test;

import static ceri.common.test.AssertUtil.assertFind;
import static ceri.common.test.AssertUtil.assertNotFound;
import static java.lang.reflect.AccessFlag.STATIC;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import org.junit.After;
import org.junit.Test;
import ceri.common.test.FileTestHelper;
import ceri.common.text.StringUtil;
import ceri.common.util.CloseableUtil;
import ceri.jna.util.JnaOs;

public class CSymbolGenBehavior {
	private FileTestHelper files;
	private StringBuilder b;
	private PrintStream out;

	public static class C {
		public static final int IGNORE = -1;
		public static final byte VAL1 = 1;
		public static final short VAL2 = 2;
		public static final String VAL3 = "3";
		public static int VAL4 = 4;
		public static final long VAL5 = 5;
		public static final double VAL6 = 0.5;
		public static final Integer NUL = null;
		public static final int PRIV1 = 1;
		public static final int PRIV2 = 2;

		public static class Sub {
			public static final int IGNORE = -1;
			public static final int SUB1 = 1;
		}

		public enum EnumNone {
			ENUMX,
			ENUMY
		}

		public enum EnumVal {
			ENUM0(0),
			ENUM1111(0x1111);

			public final int value;

			private EnumVal(int value) {
				this.value = value;
			}
		}

		public static class Empty {}
	}

	@After
	public void after() {
		CloseableUtil.close(out, files);
		files = null;
		out = null;
		b = null;
	}

	@Test
	public void shouldGenerateCode() {
		var gen = CSymbolGen.of();
		gen.include("test");
		gen.pre.lines.add("").add("#define EMPTY").add("#define STRING \"string\"")
			.add("#define INT (1+1)");
		gen.main.lines.syms("UNDEFINED", "EMPTY", "STRING").symi("INT", 2).vsymi("INT", 2)
			.vsymi("INT", 3);
		var code = gen.generate();
		assertFind(code, "\\Q#include <test.h>\\E");
		assertFind(code, "\\Q#define EMPTY\n\\E");
		assertFind(code, "\\Q#define STRING \"string\"\n\\E");
		assertFind(code, "\\QSYM(UNDEFINED)\\E");
		assertFind(code, "\\QSYM(EMPTY)\\E");
		assertFind(code, "\\QSYM(STRING)\\E");
	}

	@Test
	public void shouldGenerateFileAndInstructions() throws IOException {
		files = FileTestHelper.builder().build();
		initOut();
		var gen = CSymbolGen.of();
		gen.main.lines.add(C.Sub.class);
		CSymbolGen.generate(gen, files.path("test.c").toString(), out);
		assertFind(b, "(?s)Generated c file.*gcc test.c -o test");
		var file = Files.readString(files.path("test.c"));
		assertFind(file, "// Generated by");
		assertFind(file, "\\Q#if defined(IGNORE)\\E");
		assertFind(file, "\\QCERI_VSYMI(IGNORE,%d);\\E", 0xffffffffL);
	}

	@Test
	public void shouldGenerateInstructionsWithoutFile() {
		initOut();
		var gen = CSymbolGen.of();
		gen.main.lines.add(C.Sub.class);
		CSymbolGen.generate(gen, null, out);
		var s = b.toString();
		assertFind(s, "\\QCERI_VSYMI(IGNORE,%d);\\E", 0xffffffffL);
		assertFind(s, "(?s)Build.*gcc file.c -o file");
	}

	@Test
	public void shouldGenerateWithoutFileOrOutput() {
		var gen = CSymbolGen.of();
		gen.main.lines.add(C.Sub.class);
		CSymbolGen.generate(gen, null, null);
	}

	@Test
	public void shouldExcludeTypes() {
		var gen = CSymbolGen.of();
		gen.fieldFilter(CSymbolGen.fieldFilter().exclude(C.EnumVal.class, C.Sub.class));
		gen.main.lines.add(C.class);
		var code = gen.generate();
		assertFind(code, "ENUMX");
		assertNotFound(code, "SUB1");
		assertNotFound(code, "ENUM0");
	}

	@Test
	public void shouldFilterFieldTypes() {
		var gen = CSymbolGen.of();
		gen.fieldFilter(CSymbolGen.fieldFilter().types(Enum.class));
		gen.main.lines.add(C.class);
		var code = gen.generate();
		assertFind(code, "(?s)ENUMX.*ENUMY.*ENUM0.*ENUM1111");
		assertNotFound(code, "VAL");
	}

	@Test
	public void shouldGenerateArchSpecificHeaderCode() {
		var gen = CSymbolGen.of();
		gen.include(JnaOs.linux, "linux");
		gen.pre.lines(JnaOs.mac).add("#define apple 1");
		var code = gen.generate();
		assertFind(code, "\\Q#ifdef __linux__\n#include <linux.h>\n#endif\\E");
		assertFind(code, "\\Q#ifdef __APPLE__\n#define apple 1\n#endif\\E");
	}

	@Test
	public void shouldGenerateStructFieldSize() {
		var gen = CSymbolGen.of();
		gen.main.lines.fsize("struct timespec", "tv_sec", "tv_nsec");
		var code = gen.generate();
		assertFind(code, "\\QFSIZE(struct timespec,tv_sec)\\E");
		assertFind(code, "\\QFSIZE(struct timespec,tv_nsec)\\E");
	}

	@Test
	public void shouldAddClassFields() {
		var gen = CSymbolGen.of();
		gen.fieldFilter(CSymbolGen.fieldFilter().exclude("IGNORE").excludeRegex("PRIV\\d+"));
		gen.main.lines.add(C.class);
		var code = gen.generate();
		assertFind(code, "\\QVSYMI(VAL1,1);\\E");
		assertFind(code, "\\QVSYMI(VAL2,2);\\E");
		assertFind(code, "\\QVSYMI(SUB1,1);\\E");
		assertNotFound(code, "\\QIGNORE\\E");
		assertNotFound(code, "\\QVAL3\\E");
		assertNotFound(code, "\\QVAL4\\E");
		assertNotFound(code, "\\QPRIV\\E");
	}

	@Test
	public void shouldAddEnumFields() {
		var gen = CSymbolGen.of();
		gen.main.lines.add(C.class);
		var code = gen.generate();
		assertFind(code, "\\QSYMI(ENUMX);\\E");
		assertFind(code, "\\QSYMI(ENUMY);\\E");
		assertFind(code, "\\Qdefined(ENUM0)\\E");
		assertFind(code, "\\Qdefined(ENUM1111)\\E");
		assertFind(code, "\\QVSYMI(ENUM0,0);\\E");
		assertFind(code, "\\QVSYMI(ENUM1111,4369);\\E");
	}

	@Test
	public void shouldHandleCEnums() {
		var gen = CSymbolGen.of();
		gen.enums(true, null, C.EnumVal.class);
		gen.main.lines.add(C.EnumVal.class);
		var code = gen.generate();
		assertNotFound(code, "\\Qdefined(ENUM0)\\E");
		assertNotFound(code, "\\Qdefined(ENUM1111)\\E");
		assertFind(code, "\\QVSYMI(ENUM0,0);\\E");
		assertFind(code, "\\QVSYMI(ENUM1111,4369);\\E");

	}

	@Test
	public void shouldAllowIntTypes() {
		var gen = CSymbolGen.of();
		gen.fieldFilter(f -> f.getName().startsWith("VAL"));
		gen.intFilter(CSymbolGen.filter().types(String.class));
		gen.main.lines.add(C.class);
		var code = gen.generate();
		assertFind(code, "\\QVSYMI(VAL3,3);\\E");
	}

	@Test
	public void shouldGenerateConditionalSymbols() {
		var gen = CSymbolGen.of();
		gen.main.lines.symiIfDef(null, "A", 1);
		gen.main.lines.symiIfDef("_B_", "B", 2);
		gen.main.lines.vsymiIfDef(null, "C", 3);
		gen.main.lines.vsymiIfDef("_D_", "D", 4);
		var code = gen.generate();
		assertFind(code, "\\QSYMI(A);\\E");
		assertNotFound(code, "\\QSYM(A);\\E");
		assertFind(code, "\\QSYMI(B);\\E");
		assertFind(code, "\\QSYM(B);\\E");
		assertFind(code, "\\QVSYMI(C,3);\\E");
		assertNotFound(code, "\\QSYM(C);\\E");
		assertFind(code, "\\QVSYMI(D,4);\\E");
		assertFind(code, "\\QSYM(D);\\E");
	}

	@Test
	public void shouldSpecifyAccessFlags() {
		var gen = CSymbolGen.of();
		gen.fieldFilter(CSymbolGen.filter().flags(STATIC));
		gen.main.lines.add(C.class);
		var code = gen.generate();
		assertFind(code, "\\QVSYMI(VAL4,4);\\E");
	}

	private void initOut() {
		b = new StringBuilder();
		out = StringUtil.asPrintStream(b);
	}
}
