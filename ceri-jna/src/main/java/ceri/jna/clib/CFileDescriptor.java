package ceri.jna.clib;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;
import ceri.common.function.Excepts;
import ceri.common.text.Regex;
import ceri.jna.clib.jna.CException;
import ceri.jna.clib.jna.CFcntl;
import ceri.jna.clib.jna.CUnistd;
import ceri.log.util.Logs;

/**
 * Encapsulates a file descriptor as a closable resource.
 */
public class CFileDescriptor implements FileDescriptor {
	private static final Pattern BROKEN_MESSAGE_REGEX = Pattern.compile("(?i)(?:remote i/o)");
	private static final Set<Integer> BROKEN_ERRORS = ErrNo.codes(ErrNo.ENOENT, ErrNo.EREMOTEIO);
	private final int fd;
	private final CInputStream in;
	private final COutputStream out;
	private final AtomicBoolean closed = new AtomicBoolean(false);

	/**
	 * Checks an exception generated by the file descriptor as to whether it is broken. Used by
	 * default for the self-healing file descriptor.
	 */
	public static boolean isBroken(Exception e) {
		if (!(e instanceof CException ce)) return false;
		if (BROKEN_ERRORS.contains(ce.code)) return true;
		return (Regex.find(BROKEN_MESSAGE_REGEX, e.getMessage()).hasMatch());
	}

	/**
	 * Encapsulates open arguments. Use Mode.NONE if mode is unspecified.
	 */
	public static record Opener(String path, Mode mode, Collection<Open> flags)
		implements Excepts.Supplier<IOException, CFileDescriptor> {
		public Opener(String path, Mode mode, Open... flags) {
			this(path, mode, List.of(flags));
		}

		@Override
		public CFileDescriptor get() throws IOException {
			return open(path, mode, flags);
		}
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Open... flags) throws IOException {
		return open(path, Arrays.asList(flags));
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Collection<Open> flags) throws IOException {
		return open(path, null, flags);
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Mode mode, Open... flags) throws IOException {
		return open(path, mode, Arrays.asList(flags));
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Mode mode, Collection<Open> flags)
		throws IOException {
		int flagsValue = Open.encode(flags);
		return new CFileDescriptor(mode == null ? CFcntl.open(path, flagsValue) :
			CFcntl.open(path, flagsValue, mode.value()));
	}

	/**
	 * Take ownership of an existing file descriptor.
	 */
	public static CFileDescriptor of(int fd) {
		return new CFileDescriptor(fd);
	}

	private CFileDescriptor(int fd) {
		if (fd < 0) throw new IllegalArgumentException("Invalid file descriptor: " + fd);
		this.fd = fd;
		in = CInputStream.of(fd);
		out = COutputStream.of(fd);
	}

	public int fd() {
		if (closed.get()) throw new IllegalStateException("File descriptor is closed: " + fd);
		return fd;
	}

	@Override
	public CInputStream in() {
		return in;
	}

	@Override
	public COutputStream out() {
		return out;
	}

	@Override
	public void accept(Excepts.IntConsumer<IOException> consumer) throws IOException {
		consumer.accept(fd());
	}

	@Override
	public <T> T apply(Excepts.IntFunction<IOException, T> function) throws IOException {
		return function.apply(fd());
	}

	@Override
	public int flags() throws IOException {
		return CFcntl.getFl(fd);
	}

	@Override
	public void flags(int flags) throws IOException {
		CFcntl.setFl(fd, flags);
	}

	@Override
	public void close() {
		if (closed.getAndSet(true)) return;
		Logs.close(in, out, () -> CUnistd.close(fd));
	}

	/**
	 * Closes the fd without throwing an exception. Returns false if an exception occurred.
	 */
	public boolean closeSilently() {
		if (closed.getAndSet(true)) return true;
		return CUnistd.closeSilently(fd);
	}

	@Override
	public int hashCode() {
		return Objects.hash(fd);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		return (obj instanceof CFileDescriptor other) && fd == other.fd;
	}

	@Override
	public String toString() {
		return String.format("fd=%d/0x%x", fd, fd);
	}
}
