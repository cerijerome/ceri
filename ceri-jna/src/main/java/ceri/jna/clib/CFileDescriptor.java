package ceri.jna.clib;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import ceri.common.data.FieldTranscoder;
import ceri.common.function.ExceptionIntConsumer;
import ceri.common.function.ExceptionIntFunction;
import ceri.common.function.ExceptionSupplier;
import ceri.common.text.RegexUtil;
import ceri.jna.clib.jna.CException;
import ceri.jna.clib.jna.CFcntl;
import ceri.jna.clib.jna.CUnistd;
import ceri.log.util.LogUtil;

/**
 * Encapsulates a file descriptor as a closable resource.
 */
public class CFileDescriptor implements FileDescriptor {
	private static final Pattern BROKEN_MESSAGE_REGEX = Pattern.compile("(?i)(?:remote i/o)");
	private static final Set<Integer> BROKEN_ERRORS = ErrNo.codes(ErrNo.ENOENT, ErrNo.EREMOTEIO);
	private final int fd;
	private final CInputStream in;
	private final COutputStream out;
	private final FieldTranscoder<IOException, OpenFlag> flags;
	private volatile boolean closed = false;

	/**
	 * Checks an exception generated by the file descriptor as to whether it is broken. Used by
	 * default for the self-healing file descriptor.
	 */
	public static boolean isBroken(Exception e) {
		if (!(e instanceof CException ce)) return false;
		if (BROKEN_ERRORS.contains(ce.code)) return true;
		return (RegexUtil.found(BROKEN_MESSAGE_REGEX, e.getMessage()) != null);
	}

	/**
	 * Encapsulates open arguments. Use Mode.NONE if mode is unspecified.
	 */
	public static record Opener(String path, Mode mode, Collection<OpenFlag> flags)
		implements ExceptionSupplier<IOException, CFileDescriptor> {
		public Opener(String path, Mode mode, OpenFlag... flags) {
			this(path, mode, List.of(flags));
		}

		@Override
		public CFileDescriptor get() throws IOException {
			return open(path, mode, flags);
		}
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, OpenFlag... flags) throws IOException {
		return open(path, Arrays.asList(flags));
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Collection<OpenFlag> flags) throws IOException {
		return open(path, null, flags);
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Mode mode, OpenFlag... flags)
		throws IOException {
		return open(path, mode, Arrays.asList(flags));
	}

	/**
	 * Opens a file.
	 */
	public static CFileDescriptor open(String path, Mode mode, Collection<OpenFlag> flags)
		throws IOException {
		int flagsValue = OpenFlag.xcoder.encodeInt(flags);
		return new CFileDescriptor(mode == null ? CFcntl.open(path, flagsValue) :
			CFcntl.open(path, flagsValue, mode.value()));
	}

	/**
	 * Take ownership of an existing file descriptor.
	 */
	public static CFileDescriptor of(int fd) {
		return new CFileDescriptor(fd);
	}

	private CFileDescriptor(int fd) {
		if (fd < 0) throw new IllegalArgumentException("Invalid file descriptor: " + fd);
		this.fd = fd;
		in = CInputStream.of(fd);
		out = COutputStream.of(fd);
		flags = FileDescriptor.flagField(() -> CFcntl.getFl(fd), flags -> CFcntl.setFl(fd, flags));
	}

	public int fd() {
		if (closed) throw new IllegalStateException("File descriptor is closed: " + fd);
		return fd;
	}

	@Override
	public CInputStream in() {
		return in;
	}

	@Override
	public COutputStream out() {
		return out;
	}

	@Override
	public void accept(ExceptionIntConsumer<IOException> consumer) throws IOException {
		consumer.accept(fd());
	}

	@Override
	public <T> T apply(ExceptionIntFunction<IOException, T> function) throws IOException {
		return function.apply(fd());
	}

	@Override
	public FieldTranscoder<IOException, OpenFlag> flags() {
		return flags;
	}

	@Override
	public void close() {
		closed = true;
		LogUtil.close(in, out, () -> CUnistd.close(fd));
	}

	public boolean closeSilently() {
		closed = true;
		return CUnistd.closeSilently(fd);
	}

	@Override
	public int hashCode() {
		return Objects.hash(fd);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		return (obj instanceof CFileDescriptor other) && fd == other.fd;
	}

	@Override
	public String toString() {
		return String.format("fd=%d/0x%x", fd, fd);
	}
}
