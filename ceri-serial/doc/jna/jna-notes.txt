JNA Notes
=========

C code analysis
---------------

Exported functions:
nm -D --defined-only libxxx.so

Lib dependencies:
readelf -d libxxx.so | grep NEEDED

Header path:
gcc -v -E -

Search
sudo find <include-path> -type f | grep '\.'h$ | xargs grep xxx
sudo find <include-path> -type f | grep '\.'h$ | xargs grep include | grep xxx/xxx'\.'h

Notes
- #define may have space, such as # define
- To check defined values, compile and run ../../lib/c/symbols.c

Man page numbers:
  1  User Commands
  2  System Calls
  3  C Library Functions
  4  Devices and Special Files
  5  File Formats and Conventions
  6  Games et. al.
  7  Miscellanea
  8  System Administration tools and Daemons


JNA coding
----------
General:
- new Memory() is not always zeroed
Structures:
- often better to use pointers to prevent auto read/write
- constructor T(null) is the same as T()
- structs created with null pointer only have placeholder memory
  - struct fields have their own independent placeholder memory 
- struct write() allocates memory
  - struct fields now have correct memory offsets
- for c struct arg (T** ref) use T.ByRef[] ref = { new T.ByRef(null) };   
- creating array from struct calls autoRead() on new array items (not original)
- CUtil.mallocArray to allocate a contiguous array of types/pointers


Projects
--------
- (purejavacomm)
- clib
- libusb
- libftdi
- spidev
- i2cdev


